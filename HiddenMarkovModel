from __future__ import division
from copy import deepcopy
from math import log
from GretchenWilson_BNFO602_logfloat_2017 import log_float
from math.pylab import *

class HMM(object):
    """
Docstring for testing HMM class
>>> A = HMM("_14223453452666665656626646643666345263452341263")
>>> forward_value = A.forward()
>>> print (forward_value)
3.68371784339e-34
>>> viterbi_prob, MPS_path = A.viterbi()
>>> print (viterbi_prob)
1.58772133063e-35
>>> print(A.sequence + '\\n' + ''.join(MPS_path))
_14223453452666665656626646643666345263452341263
SFFFFFFFFFFFFFLLLLLLLLLLLLLLLLLLLLLLFLLFFFFFFFFF
1263
"""

    def __init__(self, sequence=None, states=None, emissions=None):

        self.sequence = sequence
        self.sequence_len = len(sequence)

        if states:
            self.states = states

        else:
            self.states = {
                "S": {
                    "F": 0.5,
                    "L": 0.5,
                    },
                "F": {
                    "F": 0.95,
                    "L": 0.05,
                    },
                "L": {
                    "L": 0.90,
                    "F": 0.10,
                    }
            }

        if emissions:
            self.emissions = emissions
        else:
            self.emissions = {

                "S":
                    {
                        "_": 1
                    },
                "F":  # 'F' indicates a fair die
                    {
                        "1": 1 / 6,
                        "2": 1 / 6,
                        "3": 1 / 6,
                        "4": 1 / 6,
                        "5": 1 / 6,
                        "6": 1 / 6
                    },
                "L":  # 'L' indicates a loaded die
                    {
                        "1": 1 / 10,
                        "2": 1 / 10,
                        "3": 1 / 10,
                        "4": 1 / 10,
                        "5": 1 / 10,
                        "6": 1 / 2
                    }
            }
        self.nonstart_states = deepcopy(self.emissions)
        del self.nonstart_states['S']

        # logfloat EVERYTHING!
        for state in self.states:
            for transition_state in self.states[state]:
                self.states[state][transition_state] = log_float(self.states[state][transition_state])

        for state in self.emissions:
            for emission in self.emissions[state]:
                self.emissions[state][emission] = log_float(self.emissions[state][emission])

        # Data tables necessary for this class
        self.forward_table = [{} for k in range(self.sequence_len)]
        self.backward_table = [{} for k in range(self.sequence_len)]     # You can define these later
        self.viterbi_table = [{} for k in range(self.sequence_len)]
        self.posterior_table = [{} for k in range(self.sequence_len)]

        return

     def train_most_likely(self, training_data):
        """ Evaluates given training data to determine state transition and emission probabilities """

        state_symbol_dict = {k: {} for k in self.transitions.keys()}
        state_transition_dict = {k: {} for k in self.transitions.keys()}
        total_state_transition_counts = {k: 0 for k in self.transitions.keys()}
        total_state_emission_counts = {k: 0 for k in self.transitions.keys()}

        for symbol_seq, state_seq in training_data:
            if len(symbol_seq) != len(state_seq):
                continue

            for position in range(len(symbol_seq) - 1):
                # set variables for this position

                cur_state = state_seq[position]
                next_state = state_seq[position + 1]
                emitted_symbol = symbol_seq[position + 1]

                # increment counts
                total_state_transition_counts[cur_state] += 1
                total_state_emission_counts[next_state] += 1
                
                try:
                    state_symbol_dict[cur_state][emitted_symbol] += 1
                except KeyError:
                    state_symbol_dict[cur_state][emitted_symbol] = 0
                try:
                    state_transition_dict[cur_state][next_state] += 1
                except KeyError:
                    state_transition_dict[cur_state][next_state] = 0
                    
        for state in state_symbol_dict:
        
            for symbol in state_symbol_dict[state]:
                if state is "S":
                    state_symbol_dict[state][""] = 1
                else:
                    state_symbol_dict[state][symbol] /= total_state_emission_counts[state]
                    
        for state in state_transition_dict:
        
            for state2 in state_transition_dict[state]:
                state_transition_dict[state][state2] /= total_state_transition_counts[state]

        self.transitions = state_transition_dict
        self.emissions = state_symbol_dict

        return self.transitions, self.emissions
        
    def evaluate_path(self, path):
        """Evaluates the probability of a sequence and path given the model"""
        
        joint_probability_of_sequence_and_path = 1

        for position in range(self.sequence_len - 1):
            old_state = path[position]
            new_state = path[position + 1]

            trans_prob = self.states[old_state][new_state]
            emission = self.sequence[position + 1]
            emission_prob = self.emissions[new_state][emission]
            joint_probability_of_sequence_and_path *= trans_prob * emission_prob

        return joint_probability_of_sequence_and_path
